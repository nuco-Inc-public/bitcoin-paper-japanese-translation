# 11.計算

攻撃者が正当なチェーンよりも速く代替チェーンを生成しようとするシナリオを考える。
これが成功されたとしても、無から価値を創造したり、攻撃者が所有したことのないコインを奪ったりするなど、システムを任意に変更できるようになるわけではない。
ノードは無効な取引の支払いや、それを含んだブロックを決して受け入れないからである。
攻撃者ができることは、自分が最近使ったお金を取り戻すために、自分の取引の1つを変更しようと試みることくらいだ。
正当なチェーンと攻撃者のチェーンの争いは、バイノミアル・ランダム・ウォークとして特徴づけることができる。
成功イベントは、正当なチェーンが1ブロック拡張され、そのリードが1増加し、失敗イベントは攻撃者のチェーンが1ブロック拡張され、差が1縮まる。
攻撃者が赤字から反転する可能性はGamblers's Ruinの問題と似ている。無制限の資金を持つギャンブラーが赤字で始まり、損益分岐点に到達しようとする可能性がある無数の試行を潜在的に行うとする。彼が損害を被る確率は、以下のように計算することができる。

- p = 正当なノードが次のブロックを見つける確率
- q = 攻撃者が次のブロックを見つける確率
- qz = 攻撃者がZブロックの後ろに追いつく確率

<img src="https://latex.codecogs.com/gif.latex?q_{z}=\begin{Bmatrix}&space;1&space;&&space;if&space;p&space;\leq&space;q\\&space;(q|p)^{z}&space;&&space;if&space;p&space;>&space;q&space;\end{Bmatrix}" />


p > qと仮定すると、攻撃者が追いつくブロック数に応じて確率は指数関数的に下がる。
彼との闘いで、早く幸運を得ることができなければ、彼はさらに後ろに下がるにつれて、攻撃者のチャンスは消え去るほど小さくなるだろう。

新しいトランザクションの受信者が送信者がトランザクションを変更できないことを十分に確信するまで待つ必要がある時間を検討する。送信者は、受信者に支払ったとしばらくの間信じさせるようにした後、自分にそれを戻そうとしていると仮定する。受信者には警告が表示されますが、送信者はその時点でそれが手遅れであることを希望する。受信者は公開鍵を作成し、電子署名をする直前にそれを送信者に送る。これにより、送信者が前もって偽のチェーンを用意しておき、公開鍵が送られてきた瞬間に偽の取引を防止できる。取引が送信されると同時に、不正な送信者は密かに取引の代替バージョンを含むパラレルチェーン上で作業を開始する。受信者は取引がブロックに追加され、その後にzブロックがリンクされるまで待機する。受信者には攻撃者が行った進捗状況を正確に把握してないが、正当なブロックが平均的な時間で作成されたと仮定すると、攻撃者の進捗はポアソン分布の期待値で求められる。


<img src="https://latex.codecogs.com/gif.latex?\lambda&space;=&space;z\frac{q}{p}" />

攻撃者が追いつく確率を得るために、彼のその時点から追いつく可能性のある進歩のそれぞれの量に対してポアソン密度を掛ける

<img src="https://latex.codecogs.com/gif.latex?\sum_{k=0}^{\infty&space;}\frac{\lambda&space;^{k}e&space;^{-\lambda}}{k!}\cdot&space;\begin{Bmatrix}&space;(q|p)^{(z-k)}&space;&&space;if&space;k\leq&space;z\\&space;1&space;&&space;if&space;k>&space;z&space;\end{Bmatrix}" />

分布の無限テールの加算を避けるために並び替えると...

<img src="https://latex.codecogs.com/gif.latex?1-\sum_{k=0}^{z}\frac{\lambda&space;^{k}e&space;^{-\lambda}}{k!}(1-(q|p)^{(z-k)})" />


Cコードに変換すると...
```
#include <math.h>
double AttackerSuccessProbability(double q, int z)
{
 double p = 1.0 - q;
 double lambda = z * (q / p);
 double sum = 1.0;
 int i, k;
 for (k = 0; k <= z; k++)
 {
 double poisson = exp(-lambda);
 for (i = 1; i <= k; i++)
 poisson *= lambda / i;
 sum -= poisson * (1 - pow(q / p, z - k));
 }
 return sum;
}
```


いくつかの結果を実行すると、確率はzが増えるにしたがって指数関数的に低下することがわかる。

```
q=0.1
z=0 P=1.0000000
z=1 P=0.2045873
z=2 P=0.0509779
z=3 P=0.0131722
z=4 P=0.0034552
z=5 P=0.0009137
z=6 P=0.0002428
z=7 P=0.0000647
z=8 P=0.0000173
z=9 P=0.0000046
z=10 P=0.0000012
q=0.3
z=0 P=1.0000000
z=5 P=0.1773523
z=10 P=0.0416605
z=15 P=0.0101008
z=20 P=0.0024804
z=25 P=0.0006132
z=30 P=0.0001522
z=35 P=0.0000379
z=40 P=0.0000095
z=45 P=0.0000024
z=50 P=0.0000006
```


Pの0.1％未満のときの値は...

```
P < 0.001
q=0.10 z=5
q=0.15 z=8
q=0.20 z=11
q=0.25 z=15
q=0.30 z=24
q=0.35 z=41
q=0.40 z=89
q=0.45 z=340
```